<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-history-of-move.html"><strong aria-hidden="true">1.</strong> History of Move</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-the-language.html"><strong aria-hidden="true">1.1.</strong> The Language for Digital Assets</a></li><li class="chapter-item expanded "><a href="ch01-02-dispersion-of-move.html"><strong aria-hidden="true">1.2.</strong> The Dispersion of Move</a></li><li class="chapter-item expanded "><a href="ch01-03-enter-movement.html"><strong aria-hidden="true">1.3.</strong> Enter the Movement</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-getting-started-with-move.html"><strong aria-hidden="true">2.</strong> Getting Started with Move</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-advantages-of-move.html"><strong aria-hidden="true">2.1.</strong> Advantages of Move</a></li><li class="chapter-item expanded "><a href="ch02-02-install-movement-cli.html"><strong aria-hidden="true">2.2.</strong> Install Movement CLI</a></li><li class="chapter-item expanded "><a href="ch02-03-hello-move.html"><strong aria-hidden="true">2.3.</strong> Hello, Move!</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-domain-modeling.html"><strong aria-hidden="true">3.</strong> Planning Your Capstone Project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-domain-modeling-intro.html"><strong aria-hidden="true">3.1.</strong> Domain Modeling</a></li><li class="chapter-item expanded "><a href="ch03-02-user-journey.html"><strong aria-hidden="true">3.2.</strong> User Journey</a></li><li class="chapter-item expanded "><a href="ch03-03-architectural-diagram.html"><strong aria-hidden="true">3.3.</strong> Architectural Diagram</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-basic-move-syntax.html"><strong aria-hidden="true">4.</strong> Basic Move Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-primitive-types.html"><strong aria-hidden="true">4.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="ch04-02-comments.html"><strong aria-hidden="true">4.2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch04-03-expressions-and-scope.html"><strong aria-hidden="true">4.3.</strong> Expressions and Scope</a></li><li class="chapter-item expanded "><a href="ch04-04-control-flow.html"><strong aria-hidden="true">4.4.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="ch04-05-modules-and-imports.html"><strong aria-hidden="true">4.5.</strong> Modules and Imports</a></li><li class="chapter-item expanded "><a href="ch04-06-testing.html"><strong aria-hidden="true">4.6.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-custom-types-and-generics.html"><strong aria-hidden="true">5.</strong> Custom types and generics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-custom-types.html"><strong aria-hidden="true">5.1.</strong> Custom Types</a></li><li class="chapter-item expanded "><a href="ch05-02-getter-functions.html"><strong aria-hidden="true">5.2.</strong> Getter and Setter Functions</a></li><li class="chapter-item expanded "><a href="ch05-03-generics-intro.html"><strong aria-hidden="true">5.3.</strong> Generics Introduction</a></li><li class="chapter-item expanded "><a href="ch05-04-generics-with-multiple-types.html"><strong aria-hidden="true">5.4.</strong> Generics with Multiple Type Parameters</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/movemntdev/movement-hack" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="movement-hack-introduction"><a class="header" href="#movement-hack-introduction">Movement Hack Introduction</a></h1>
<p>This course is designed to support you as you build for build for Movement. See our <a href="https://docs.movementlabs.xyz/">docs</a> for an introduction to the Move stack. And please <a href="https://discord.gg/movementlabsxyz">join Movement Discord</a> to get involved with the community!</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="ch01-00-history-of-move.html">History of Move</a></p>
<ul>
<li><a href="ch01-01-the-language.html">The Language for Digital Assets</a></li>
<li><a href="ch01-02-dispersion-of-move.html">The Dispersion of Move</a></li>
<li><a href="ch01-03-enter-movement.html">Enter the Movement</a></li>
</ul>
</li>
<li>
<p><a href="ch02-00-getting-started-with-move.html">Getting Started with Move</a></p>
<ul>
<li><a href="ch02-01-advantages-of-move.html">Advantages of Move</a></li>
<li><a href="ch02-02-install-movement-cli.html">Install Movement CLI</a></li>
<li><a href="ch02-03-hello-move.html">Hello, Move!</a></li>
</ul>
</li>
<li>
<p><a href="ch03-00-domain-modeling.html">Planning Your Capstone Project</a></p>
<ul>
<li><a href="ch03-01-domain-modeling-intro.html">Domain Modeling</a></li>
<li><a href="ch03-02-user-journey.html">User Journey</a></li>
<li><a href="ch03-03-architectural-diagram.html">Architectural Diagram</a></li>
</ul>
</li>
<li>
<p><a href="ch04-00-basic-move-syntax.html">Basic Move Syntax</a></p>
<ul>
<li><a href="ch04-01-primitive-types.html">Primitive Types</a></li>
<li><a href="ch04-02-comments.html">Comments</a></li>
<li><a href="ch04-03-expressions-and-scope.html">Expressions and Scope</a></li>
<li><a href="ch04-04-control-flow.html">Control Flow</a></li>
<li><a href="ch04-05-modules-and-imports.html">Modules and Imports</a></li>
<li><a href="ch04-06-testing.html">Testing</a></li>
</ul>
</li>
<li>
<p><a href="ch05-00-custom-types-and-generics.html">Custom types and generics</a></p>
<ul>
<li><a href="ch05-01-custom-types.html">Custom Types</a></li>
<li><a href="ch05-02-getter-functions.html">Getter and Setter Functions</a></li>
<li><a href="ch05-03-generics-intro.html">Generics Introduction</a></li>
<li><a href="ch05-04-generics-with-multiple-types.html">Generics with Multiple Type Parameters</a></li>
</ul>
</li>
</ul>
<h2 id="feedback-and-contributions"><a class="header" href="#feedback-and-contributions">Feedback and Contributions</a></h2>
<p>We hope you enjoy the course! Please send feedback and contributions via <a href="https://discord.gg/movementlabsxyz">Discord</a> or <a href="https://github.com/movementlabsxyz/movement-hack">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-history-of-move"><a class="header" href="#the-history-of-move">The History of Move</a></h1>
<p>Welcome to the Movement! Because Move is a new language, we'll begin with a brief history. In this chapter you'll discover:</p>
<ul>
<li><a href="ch01-01-the-language.html">Why the Move language was invented</a></li>
<li><a href="ch01-02-dispersion-of-move.html">How Move came to be used on multiple blockchain networks</a></li>
<li><a href="ch01-03-enter-movement.html">What Movement Labs is doing to spread Move adoption</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-move-a-language-designed-for-digital-assets"><a class="header" href="#introduction-to-move-a-language-designed-for-digital-assets">Introduction to Move: A Language Designed for Digital Assets</a></h1>
<p>Get to know Move, a language specifically developed for handling digital assets effectively and safely.</p>
<h2 id="what-is-move"><a class="header" href="#what-is-move">What is Move?</a></h2>
<p>Move is a language crafted by the Diem project team at Facebook in 2020. Its design mimics some principles from Rust, with a focus on enhancing the management of digital assets types on Blockchain technologies. With Move, the traditional security risks and inefficiencies associated with earlier languages are mitigated.</p>
<p><img src="./img/move_architecture.png" alt="Move architecture diagram" title="Move architecture diagram" /></p>
<h2 id="characteristics-of-move"><a class="header" href="#characteristics-of-move">Characteristics of Move</a></h2>
<p>Here are some key features that make Move a standout language:</p>
<ul>
<li><strong>Resources Concept</strong>: Move emphasizes a resources paradigm where digital assets are seen as distinct items that can't be copied or misplaced.</li>
<li><strong>Move Prover</strong>: This is an in-built validation tool in Move. Its responsibility is to ensure that programs align with the rules declared and are free from errors. This boosts its security.</li>
<li><strong>BCS Bytecode Compilation</strong>: Programs written in Move are compiled into Binary Canonical Serialization (BCS) bytecode, a format that's both secure and efficient for different Blockchain applications.</li>
<li><strong>Flexibility and Scalability</strong>: Move supports a range of applications from simple transactions to complex financial commitments. It also allows developers to build reusable modules.</li>
<li><strong>Open Source</strong>: Move is open-source and governed by the community. This allows for adjustments and evolution to meet the changing trends in digital finance.</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Move provides a solid framework for managing digital assets efficiently and securely. Its innovative characteristics and community-driven growth ensure that Move stays relevant in digital finance.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li>The Language of Money, Part One: What Motivated the Creation of Move? Diem Blog: <a href="https://www.diem.com/en-us/blog/why-build-move/">https://www.diem.com/en-us/blog/why-build-move/</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-dispersion-of-move"><a class="header" href="#the-dispersion-of-move">The Dispersion of Move</a></h1>
<p>This lesson will walk you through on the history and expansion of Move, a key smart contract language developed originally for the Diem project by Facebook, but now used across various blockchains.</p>
<h2 id="the-origin-facebooks-dream"><a class="header" href="#the-origin-facebooks-dream">The Origin: Facebook's Dream</a></h2>
<p>Move was initially part of Facebook's ambitious project Libra, later renamed as Diem. It was developed to overcome the limitations of existing blockchain languages, especially in terms of security and digital asset management. Their intention was to create a globally accessible and efficient payment system.</p>
<h2 id="the-journey-beyond-diem"><a class="header" href="#the-journey-beyond-diem">The Journey Beyond Diem</a></h2>
<p>Although Diem faced regulatory approval obstacles, the innovative capabilities of Move managed to capture the broader interest of the blockchain community. The principles and potential of Move were too significant to be restricted to just a single project.</p>
<h2 id="the-dissemination-aptos-sui-and-further"><a class="header" href="#the-dissemination-aptos-sui-and-further">The Dissemination: Aptos, Sui, and Further</a></h2>
<p>Among the first to adopt Move for their platforms were Aptos and Sui, both initiated by ex-members of the Diem team.</p>
<p><strong>Aptos</strong>: Aptos focused on refining Move to improve security features and asset handling capabilities, aiming for a user-friendly blockchain ecosystem.</p>
<p><strong>Sui</strong>: Sui, targeting scalability and customizability, modified Move to support a new consensus mechanism and state management system, boosting speed and flexibility.</p>
<p><strong>Other Initiatives</strong>: Platforms like Starcoin, 0L, and Celo have employed Move for their smart contracts. Other platforms like Solana are examining its integration.</p>
<p>Now <strong>Movement</strong> is working on interoperability of Move-EVM, among other innovations.</p>
<h2 id="the-legacy-the-growing-ecosystem-of-move"><a class="header" href="#the-legacy-the-growing-ecosystem-of-move">The Legacy: The Growing Ecosystem of Move</a></h2>
<p>Present times sees Move not just as a programming language, but as an integral part of a growing ecosystem that extends across various blockchains. By addressing the sophisticated needs of digital asset management, Move has set a new standard in blockchain development, emphasizing safety, flexibility, and scalability.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The spread of Move from Diem to platforms like Aptos and Sui highlights the robust design of the language and the innovation drive of the blockchain community. The journey of Move, from a Facebook initiative to a cornerstone of blockchain technology, showcases how good ideas can surpass their origins and adapt to wider applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-movement"><a class="header" href="#getting-started-with-movement">Getting Started with Movement</a></h1>
<p>In this guide, you'll learn about the innovative network of modular Move-based blockchains developed by Movement Labs, designed to enhance security and interconnectivity in the blockchain world.</p>
<h2 id="what-is-movement-labs"><a class="header" href="#what-is-movement-labs">What is Movement Labs?</a></h2>
<p>Movement was born from a simple idea: What If you could take advantage of the Move programming language within any distributed environment?</p>
<p>At Movement Labs, we've come together to share our passion for Move with the industry and make our favorite programming language available to as many people around the world as possible. By creating seamless standardization across infrastructures, we can unlock innovation for all.</p>
<p>This is about creating a world where crypto is not just a currency or a technology, it's about creating a movement that brings us all closer together.</p>
<h2 id="core-principles-of-movement"><a class="header" href="#core-principles-of-movement">Core Principles of Movement</a></h2>
<ol>
<li>
<p><strong>Unified Ecosystem</strong>: Movement Labs merges diverse blockchain platforms under one infrastructure, eliminates barriers typically associated with silos, and fosters seamless collaboration and innovation. Our standardized interface streamlines interactions across platforms, making the blockchain ecosystem more approachable to both developers and users.</p>
</li>
<li>
<p><strong>Accessibility and Inclusivity</strong>: Our goal is to make blockchain technology more democratic, user-friendly, and accessible to everyone. To achieve this, we created the Movement SDK that complements existing frameworks, such as the EthereumVM or EVM. This provides universal compatibility and easy integration, making adoption more effortless.</p>
</li>
<li>
<p><strong>Interconnectivity for Open Innovation</strong>: Movement is structured to enhance connectivity among various platforms. This allows users to collaborate freely and take advantage of advancements from the broader blockchain spectrum, fostering a culture of joint innovation where ideas can grow and be implemented across different blockchains.</p>
</li>
<li>
<p><strong>Future-proof and Community-driven</strong>: Movement evolves as blockchain technology progresses, ensuring all projects stay at the leading edge of innovation. At its core, Movement is powered by an active community of builders and innovators passionate about shaping the future of blockchain.</p>
</li>
</ol>
<h2 id="building-a-lasting-legacy"><a class="header" href="#building-a-lasting-legacy">Building a Lasting Legacy</a></h2>
<p>At Movement Labs, we're more than a technology provider. We're pioneers leading a movement with an aim to reconfigure the blockchain landscape. Our concentration on accessibility, interconnectivity, and community involvement isn't just about crafting products — it's about building a rich legacy that will leave a positive and lasting impact.</p>
<h2 id="check-your-knowledge-and-earn-rewards"><a class="header" href="#check-your-knowledge-and-earn-rewards">Check your knowledge and earn rewards</a></h2>
<iframe data-tally-src="https://tally.so/embed/mJ6YyR?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="273" frameborder="0" marginheight="0" marginwidth="0" title="Movement Hack Chapter 1 Quiz"></iframe><script>var d=document,w="https://tally.so/widgets/embed.js",v=function(){"undefined"!=typeof Tally?Tally.loadEmbeds():d.querySelectorAll("iframe[data-tally-src]:not([src])").forEach((function(e){e.src=e.dataset.tallySrc}))};if("undefined"!=typeof Tally)v();else if(d.querySelector('script[src="'+w+'"]')==null){var s=d.createElement("script");s.src=w,s.onload=v,s.onerror=v,d.body.appendChild(s);}</script>
<h2 id="join-the-movement"><a class="header" href="#join-the-movement">Join the Movement</a></h2>
<p>If you haven't joined the <a href="https://discord.gg/movementlabsxyz">Discord</a> yet, do it now to stay in sync with all the next moves!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-move"><a class="header" href="#getting-started-with-move">Getting Started with Move</a></h1>
<p>This chapter gets you building with Move. You'll master:</p>
<ul>
<li><a href="ch02-01-advantages-of-move.html">The advantages of Move</a></li>
<li><a href="ch02-02-install-movement-cli.html">How to install Movement CLI</a></li>
<li><a href="ch02-03-hello-move.html">How to deploy a Move contract</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advantages-of-move"><a class="header" href="#advantages-of-move">Advantages of Move</a></h1>
<p>In this lesson, you'll learn fundamental properties of Move, including resource-orientation and type linearity, and how Move addresses specific smart contract vulnerabilities.</p>
<h2 id="resource-orientation-and-the-blockchain"><a class="header" href="#resource-orientation-and-the-blockchain">Resource-orientation and the blockchain</a></h2>
<p>Resource-orientation is a fundamental concept in programming languages like Move that greatly benefits the blockchain ecosystem. By aligning with the principles of resource-oriented programming, the blockchain can enhance security, efficiency, and reliability of smart contracts.</p>
<h2 id="stack-model-programming-and-function-ownership"><a class="header" href="#stack-model-programming-and-function-ownership">Stack Model Programming and Function Ownership</a></h2>
<p>In resource-oriented programming, like Move, the stack model is employed to manage data ownership and control access. Take for example the following unsafe C program.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void printAndFree(char* data) {
    printf("Data: %s\n", data);
    free(data); // Function takes ownership and frees the memory
}

int main() {
    char* value = (char*)malloc(strlen("Hello") + 1);
    strcpy(value, "Hello");
    
    printAndFree(value); // Pass ownership of 'value' to the function

    // Attempt to access the value after it has been freed
    printf("Data after freeing: %s\n", value); // Unsafe access!

    return 0;
}
</code></pre>
<p>{{#quiz ../quizzes/ch02-01-unsafe-access.toml}}</p>
<p>In Move, this kind of unsafe access would not be possible because of strict ownership conditions.</p>
<p>Each function owns any resources it creates and is responsible for its lifecycle. This ownership model ensures that resources are properly managed and prevents unauthorized access or modification, bolstering the security of blockchain-based applications.</p>
<h2 id="access-restriction-all-the-way-down"><a class="header" href="#access-restriction-all-the-way-down">Access Restriction All the Way Down</a></h2>
<p>Resource-oriented programming languages like Move implement access restrictions at all levels of code execution. From the top-level contract to individual functions, access to resources is strictly controlled. This granular access control minimizes the risk of unauthorized operations and ensures that only authorized parties can interact with specific resources, promoting secure and auditable transactions on the blockchain.</p>
<h2 id="type-linearity-and-ownership"><a class="header" href="#type-linearity-and-ownership">Type Linearity and Ownership</a></h2>
<p><em>Linear type:</em> a type with an enforced the restriction that variables or values of the type can be used exactly once. In other words, each linear value has a unique owner or consumer, and it must be used or consumed linearly without duplication or uncontrolled consumption.</p>
<pre><code class="language-javascript">f(a) -&gt; g(a) -&gt; h(a)
</code></pre>
<p><em>Non-linear type:</em> a type without an enforced the restriction that variables or values of the type can be used exactly once. Variables or values of non-linear types can be used or accessed multiple times without restrictions.</p>
<pre><code class="language-javascript">f(a) -&gt;
    g(a)
    + h(a) -&gt; 
        c(a)
        + k(a)
        + p(a)
</code></pre>
<p>Type linearity is a crucial aspect of resource-oriented programming that enforces the linear use of resources. In Move, resources generally have linear types, meaning they can only be consumed or moved, not duplicated. This feature prevents resource duplication, reduces memory consumption, and eliminates the risk of double-spending, ensuring the integrity and accuracy of transactions on the blockchain.</p>
<p>{{#quiz ../quizzes/ch02-01-type-linearity.toml}}</p>
<h2 id="how-does-move-address-common-smart-contract-vulnerabilities"><a class="header" href="#how-does-move-address-common-smart-contract-vulnerabilities">How does Move address common smart contract vulnerabilities?</a></h2>
<p>The resource-orientation and type-linearity of the Move programming language play a significant role in avoiding common smart contract vulnerabilities. Here's how these features address specific vulnerabilities:</p>
<blockquote>
<p><strong>1. Reentrancy Attacks:</strong> In a reentrancy attack, a malicious contract calls back into the calling contract before the first execution completes, potentially leading to unexpected behavior or loss of funds. Move's resource-orientation ensures that resources (which include digital assets) cannot be duplicated and are used in a linear fashion. This linearity means that once a resource is moved, it cannot be accessed again within the same transaction, thereby mitigating reentrancy risks.</p>
<p><strong>2. Integer Overflow and Underflow:</strong> These occur when an operation attempts to create a numerical value outside the range that can be represented with a given number of bits. Move's type system can enforce range checks on numeric values, reducing the risk of overflow and underflow errors.</p>
<p><strong>3. Unintended Ether Loss:</strong> In Ethereum, contracts can be accidentally destroyed with ether still inside, leading to permanent loss of funds. Move's resource model can prevent this by ensuring that resources are accounted for at all times, making it much harder to lose them accidentally.</p>
<p><strong>4. Frozen Ether:</strong> Ether can become frozen in a contract due to bugs. Move's stronger guarantees about the state and its manipulation help avoid such scenarios, as the language is designed to make the effects of code more predictable and transparent.</p>
<p><strong>5. Timestamp Dependence and Miner Manipulation:</strong> Some contracts rely on block timestamps, which can be slightly manipulated by miners. Move's approach to resources and transactions doesn't inherently solve this, but its more predictable environment can help developers avoid relying on such external and manipulable factors.</p>
<p><strong>6. Short Address/Parameter Attack:</strong> This happens due to inconsistent handling of input data length. Move's strong typing and explicit resource management can help avoid this by enforcing correct input handling and data lengths.</p>
<p><strong>7. Denial of Service (DoS) via Block Gas Limit:</strong> Attackers might stuff blocks with expensive computations to exhaust a contract's gas. While this is more of a systemic issue, Move's efficiency and predictability in resource handling can mitigate some of the risks.</p>
<p><strong>8. Unknown Function Calls:</strong> In Ethereum, sending Ether to unknown functions can lead to vulnerabilities. Move's explicit resource accounting can help avoid such scenarios by making it clear where and how resources are flowing.</p>
</blockquote>
<p>Move’s focus on safety, predictability, and explicit resource management addresses these vulnerabilities effectively, helping developers write safer smart contracts. This is particularly crucial in blockchain environments, where contract bugs and vulnerabilities can lead to significant financial losses and are often irreversible due to the immutable nature of blockchain technology.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-movement-cli"><a class="header" href="#install-movement-cli">Install Movement CLI</a></h1>
<p>Next, you'll install Movement CLI.</p>
<p>Consult the <a href="https://docs.movementlabs.xyz">Movement Docs</a> and choose the setup option that works best for you.</p>
<p>Before continuing in the course, verify that <code>movement</code> is installed:</p>
<pre><code class="language-bash">movement --version 
</code></pre>
<p>Next, you'll deploy a simple end-to-end Move chat dApp!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-move"><a class="header" href="#hello-move">Hello, Move</a></h1>
<p>If you've installed Movement CLI, congratulations!</p>
<p>If not, please <a href="ch02-02-install-movement-cli.html">return to the previous lesson</a> and install Movement CLI.</p>
<p>Now that you have Movement CLI installed, it's time to deploy something to Movement. Ideally and end-to-end (E2E) dApp.</p>
<p>If you'd prefer to build up your confidence first, it's fine to deploy a simple module. Just <a href="https://docs.movementlabs.xyz/developers/tutorials/deploy/aptos-module">follow this guide</a>. It doesn't require any coding experience.</p>
<p>An E2E dApp is just an on-chain module or modules paired with a front end like a Next.js or Vite app. So it's not too much more complicated than deploying a module.</p>
<p>In this lesson, you'll build a simple dApp that allows users to post messages to a chat room.</p>
<p>Just like in the module deployment guide, you don't need any coding experience to deploy this dApp. You only have to be able to follow ste-by-step directions 👍🏼</p>
<p>Try the app <a href="https://main.d2761w90g9sxb3.amplifyapp.com/">here</a>.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Install Movement CLI:</p>
<pre><code class="language-bash">&lt;(curl -fsSL https://raw.githubusercontent.com/movemntdev/M1/main/scripts/install.sh) --latest
</code></pre>
<p>Clone the dApp repository:</p>
<pre><code class="language-bash">git clone https://github.com/movementlabsxyz/movement-dapp-workshop/
cd movement-dapp-workshop
</code></pre>
<h2 id="building-the-chat-dapp"><a class="header" href="#building-the-chat-dapp">Building the Chat dApp</a></h2>
<p>This dApp is built using the Aptos Move language. The dApp is located in the aptos directory. Once inside the repository, navigate to the aptos directory:</p>
<pre><code class="language-bash">cd aptos
</code></pre>
<h2 id="publish-module"><a class="header" href="#publish-module">Publish Module</a></h2>
<p>Aptos language requires you to initialize the Move environment:</p>
<pre><code class="language-bash">movement aptos init
</code></pre>
<p>Then you can publish the module:</p>
<pre><code class="language-bash">movement aptos move publish --named-addresses chat_addr=default
</code></pre>
<h2 id="test-front-end"><a class="header" href="#test-front-end">Test Front End</a></h2>
<p>To test the front end, navigate to the frontend directory and run the following command to start the front end server.</p>
<pre><code class="language-bash">npm i &amp;&amp; npm run dev
</code></pre>
<p>You will be able to see your frontend at <a href="http://localhost:3000">http://localhost:3000</a>.</p>
<p>Take a look at <code>aptos/frontend/components/Chat.tsx</code>. This file contains the logic for the chat room. The Chat component is responsible for fetching the chat messages, displaying them and posting new messages to the chat room.</p>
<p>In line 21, replace the address after <code>{ "address":</code>  with the address of the <code>chat_addr</code> you published:</p>
<pre><code class="language-bash">const abi = { "address": "0xYOUR_ADDRESS", (...)}"
</code></pre>
<p>Make sure the address starts with <code>0x</code> else add it. That should be available in <code>.aptos/config.yaml</code> file as the <code>account</code> field.</p>
<p>Now you can try running your transactions on the frontend and see the chat messages being posted.</p>
<h2 id="chapter-quiz-check-your-knowledge-and-earn-rewards"><a class="header" href="#chapter-quiz-check-your-knowledge-and-earn-rewards">Chapter Quiz: Check your knowledge and earn rewards</a></h2>
<iframe data-tally-src="https://tally.so/embed/3XDkBL?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="418" frameborder="0" marginheight="0" marginwidth="0" title="Movement Hack Chapter 2 Quiz"></iframe><script>var d=document,w="https://tally.so/widgets/embed.js",v=function(){"undefined"!=typeof Tally?Tally.loadEmbeds():d.querySelectorAll("iframe[data-tally-src]:not([src])").forEach((function(e){e.src=e.dataset.tallySrc}))};if("undefined"!=typeof Tally)v();else if(d.querySelector('script[src="'+w+'"]')==null){var s=d.createElement("script");s.src=w,s.onload=v,s.onerror=v,d.body.appendChild(s);}</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planning-your-capstone-project"><a class="header" href="#planning-your-capstone-project">Planning your capstone project</a></h1>
<p>You'll be investing a decent amount of time building your capstone project. Even an hour or two a day working on it is enough, but it takes commitment and dedication to get a worthwhile project done. So, whether it's a public good, a for-profit dApp or service, or something completely different, your project should be something that moves you.</p>
<p>This chapter will guide you to plan your capstone project in the following ways:</p>
<ul>
<li><a href="ch03-01-domain-modeling.html">Understanding principles of domain modeling</a></li>
<li><a href="ch03-02-user-journey.html">Writing the user journey for your project</a></li>
<li><a href="ch03-03-architectural-diagram.html">Creating an archictual diagram to model your project's domain</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-modeling-introduction"><a class="header" href="#domain-modeling-introduction">Domain Modeling Introduction</a></h1>
<p>To plan your dApp, you'll write a user journey and then model your dApp's domain.</p>
<p>A domain model is a visual representation of the concepts and objects related to your dApp. There's no "right" or "wrong" format for domain modeling. As long as the model accurately represents all the components of your dApp's domain in a way that helps you buidl, you're good!</p>
<h2 id="example-the-domain-model-for-move"><a class="header" href="#example-the-domain-model-for-move">Example: The Domain Model for Move</a></h2>
<p>Using the architecture diagram for Move, we can understand how a picture is worth a thousand - or at least a few dozes - words:</p>
<p><img src="./img/move_architecture.png" alt="Move architecture diagram" title="Move architecture diagram" /></p>
<p>The first thing that stands out is that the Move high level architecture is divided into two parts, linked by the dashed arrow labeled "SERIALIZED MOVE BYTECODE".</p>
<p>We can see steps to compile Move code on the left side of the diagram:</p>
<ol>
<li>The Move source program's "ingredients" (the Move stdlib and custom scripts and modules) are submitted to the source language compiler.</li>
<li>The Move code is compiled into an intermediate language.</li>
<li>The intermediate language is serialized into Move bytecode.</li>
</ol>
<p>All of the above is boxed in and labeled "Move tool chain" so we can visually see that those parts of the system are one group.</p>
<p>The dashed arrow conveys a sense of the serialized Move bytecode embarking on a journey, ending in its execution:</p>
<ol>
<li>A script is executed or a module is published (or both).</li>
<li>The Move Virtual Machine receives and processes the transaction bytecode as well as other txn details, such as the signature.</li>
<li>Lifecycle services help coordinate the MoveVM writing to and reading from storage.</li>
</ol>
<p>As you can see, something as magnificent as the Move programming language, can be represented in a relatively simple diagram.</p>
<p>As you plan your dApp or service you'll build on Movement, first you'll write out your user's journey as they experience what you're building.</p>
<p>Then you'll create a diagram of the system to represent that journey.</p>
<p>You'll even label your diagram with Move code, so when it's time to write your codebase, you'll already know how everything will fit together.</p>
<p>Let's Move!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-journey"><a class="header" href="#user-journey">User Journey</a></h1>
<p>A user journey, or user story is a narrative about your dApp from your dApp user's perspective. It shows their experience with your dApp, step by step. It's essential to plan your user journey before you build your dApp, because the way you build the dApp should reflect what the user's experience will be.</p>
<blockquote>
<h2 id="chat-room-user-journey-example"><a class="header" href="#chat-room-user-journey-example">Chat Room User Journey Example</a></h2>
<p>"I went to this site called Move Chat. There were all these messages getting posted, from lots of different wallets. I connected my wallet with a button in the upper right corner. And then I typed in my first message: "Hello, Move!" I clicked Send, signed with my wallet, and my message posted, onto the blockchain! I've been using Move Chat for months now - met several great friends and business partners on there and love the new features they keep adding.</p>
</blockquote>
<p>In the chapter quiz in the next lesson, you'll write a user journey for your dream dApp. So please start envisioning what it's like for your users to use your dApp now!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-dapps-architectural-diagram"><a class="header" href="#your-dapps-architectural-diagram">Your dApp's architectural diagram</a></h1>
<p>To create a diagram of Move Chat, start by looking at the types and functions specified in the module code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct ChatRoom has key, store {
        messages: vector&lt;Message&gt;,
        message_count: u64,
    }

    struct Message has key, store, copy {
        sender: address,
        // Post's text.
        text: vector&lt;u8&gt;,
        // Post's timestamp.
        timestamp: u64,
        // Set if referencing an another object (i.e., due to a Like, Retweet, Reply etc).
        // We allow referencing any object type, not only Message NFTs.
        ref_id: Option&lt;address&gt;,
        // app-specific metadata. We do not enforce a metadata format and delegate this to app layer.
        metadata: vector&lt;u8&gt;,
    }

    fun init_module(account: &amp;signer) {
        let room = ChatRoom {
            messages: vector::empty(),
            message_count: 0,
        };
        move_to&lt;ChatRoom&gt;(account, room);
    }

    /// Create a new chat room.
    public entry fun create_chat_room(account: &amp;signer) {
        let addr = signer::address_of(account);
        assert!(!exists&lt;ChatRoom&gt;(addr), E_CHAT_ROOM_EXISTS);
        let room = ChatRoom {
            messages: vector::empty(),
            message_count: 0,
        };
        move_to(account, room);
    }

    /// Simple Message object getter.
    #[view]
    public fun get_messages(addr: address) : vector&lt;Message&gt; acquires ChatRoom {
        let room = borrow_global&lt;ChatRoom&gt;(addr);
        room.messages
    }
<span class="boring">}</span></code></pre></pre>
<p>There are three main types: <code>ChatRoom</code>, <code>Message</code> and a <code>&amp;signer</code> (<code>account</code>).</p>
<p>They can be represented in the following way:</p>
<p><img src="./img/ch03-01-diagram-chatroom-init-module.png" alt="The chat dApp&#39;s init module function diagram" title="Diagram: The chat dApp&#39;s init module function" /></p>
<p><code>init_module</code> is a function that gets called once, when the module is first deployed.</p>
<p><code>init_module</code> takes in a reference to a <code>signer</code> then creates a new <code>ChatRoom</code> object and moves it to the signer's account address.</p>
<p>Here's one way to represent that with a diagram:</p>
<p><img src="./img/ch03-01-diagram-chatroom-init-module.png" alt="The chat dApp&#39;s init module function diagram" title="Diagram: The chat dApp&#39;s init module function" /></p>
<p>In the above diagram, an asterisk (*) represents creating a new instance of some type.</p>
<p>The angle bracket (&gt;) represents moving a resource to an account.</p>
<ul>
<li><strong>Step 0:</strong> The wallet (<code>account</code>) calls the <code>init_module</code> function</li>
<li><strong>Step 1:</strong> <code>init_module</code> creates a new <code>ChatRoom</code> resource</li>
<li><strong>Step 2:</strong> The <code>ChatRoom</code> resource is moved to <code>account</code>.</li>
</ul>
<h2 id="chapter-quiz-submit-user-journey-and-architecture-diagram-for-your-dapp"><a class="header" href="#chapter-quiz-submit-user-journey-and-architecture-diagram-for-your-dapp">Chapter quiz: Submit user journey and architecture diagram for your dApp</a></h2>
<iframe data-tally-src="https://tally.so/embed/3qd7DY?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="273" frameborder="0" marginheight="0" marginwidth="0" title="Movement Hack Chapter 3 Quiz"></iframe><script>var d=document,w="https://tally.so/widgets/embed.js",v=function(){"undefined"!=typeof Tally?Tally.loadEmbeds():d.querySelectorAll("iframe[data-tally-src]:not([src])").forEach((function(e){e.src=e.dataset.tallySrc}))};if("undefined"!=typeof Tally)v();else if(d.querySelector('script[src="'+w+'"]')==null){var s=d.createElement("script");s.src=w,s.onload=v,s.onerror=v,d.body.appendChild(s);}</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-move-syntax"><a class="header" href="#basic-move-syntax">Basic Move Syntax</a></h1>
<p>By now, you have some experience publishing modules to the blockchain and interacting with them. And you've begun planning your dream dApp. Congratulations! You are well on your way to being a master Move developer.</p>
<p>In this chapter, you'll learn or review the basics of the Move language:</p>
<ul>
<li><a href="ch04-01-primitive-types.html">Primitive Types</a></li>
<li><a href="ch04-02-comments.html">Comments</a></li>
<li><a href="ch04-03-expressions-and-scope.html">Expressions and Scope</a></li>
<li><a href="ch04-04-control-flow.html">Control Flow</a></li>
<li><a href="ch04-05-modules-and-imports.html">Modules and Imports</a></li>
<li><a href="ch04-06-testing.html">Testing</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h1>
<p>After completing this lession, you'll be able to define and assign values to primitive types (integer types, as operator, boolean, address).</p>
<h2 id="understanding-primitive-types-in-move-with-everyday-examples"><a class="header" href="#understanding-primitive-types-in-move-with-everyday-examples">Understanding Primitive Types in Move with Everyday Examples</a></h2>
<p>In the world of Move, the programming language used for blockchain development, there are some basic building blocks known as primitive types. These are the simple types used to represent numbers, whether something is true or false (boolean values), and unique identifiers for accounts or wallets on the blockchain (addresses). Let's dive into what these primitive types look like, using examples you might encounter in real life.</p>
<h2 id="integer-types-counting-and-measuring"><a class="header" href="#integer-types-counting-and-measuring">Integer Types: Counting and Measuring</a></h2>
<p>Move uses three types of integers: <code>u8</code>, <code>u64</code>, and <code>u128</code>. You can think of integers like the numbers you use to count things. For example:</p>
<ul>
<li>
<p><code>u8</code> could be used to count the number of books on your shelf (up to 255, because <code>u8</code> ranges from 0 to 255).</p>
</li>
<li>
<p><code>u64</code> could help you count the number of grains of sand on a beach (up to 18 quintillion!).</p>
</li>
<li>
<p><code>u128</code> is for when you really need to count many more things, like all the stars in the universe.</p>
</li>
</ul>
<p>Here's how you might see integers used in a Move script:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun main() {
        let a: u8; // Maybe this is for counting up to 10 cookies.
        a = 10;

        let a: u64 = 10; // Counting something bigger, like 10 whales.

        let a = 10; // Move knows this is a number, likely a small one.

        let a = 10u128; // Now we're counting something huge, like 10 galaxies!

        // Using numbers in decisions
        if (a &lt; 10) {}; // If we have fewer than 10, do something.

        // Specifying the type explicitly
        if (a &lt; 10u8) {}; // Same idea, but we're making sure Move knows the size.
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="operator-as-changing-your-perspective"><a class="header" href="#operator-as-changing-your-perspective">Operator <code>as</code>: Changing Your Perspective</a></h2>
<p>Sometimes, you need to compare things of different sizes, like if a cup of water will fill a bucket. In Move, you can change the "size" of your integer using the as operator, to make sure you're comparing apples to apples.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun main() {
        let a: u8 = 10; // A small number, like 10 marbles.
        let b: u64 = 100; // A bigger number, like 100 apples.

        // Comparing marbles to apples, we need to make sure they're seen the same way.
        if (a == (b as u8)) abort 11; // Check if 10 marbles are equal to 100 apples, viewed as marbles.
        if ((a as u64) == b) abort 11; // Or vice versa.
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="boolean-yes-or-no-true-or-false"><a class="header" href="#boolean-yes-or-no-true-or-false">Boolean: Yes or No, True or False</a></h2>
<p>Booleans are straightforward – they can only be true or false. Think of them like answering a yes-or-no question: "Is it sunny outside?"</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun main() {
        // Declaring whether it's sunny or not
        let b : bool; b = true; // Yes, it is sunny.
        let b : bool = true; // Still sunny.
        let b = true; // Move knows it's about whether it's sunny.
        let b = false; // Now it's not sunny.
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="address-identifying-where-things-belong"><a class="header" href="#address-identifying-where-things-belong">Address: Identifying Where Things Belong</a></h2>
<p>In the blockchain world, an address is like the address of your house, but for your digital wallet or account. It's how you receive things (like cryptocurrency) or where you send them from.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun main() {
        let addr: address; // Like saying, "This is where I live."

        // Use your specific blockchain address here, like your home address but for digital transactions.
        addr = {{sender}}; // Replace `{{sender}}` with your actual address.

        // Addresses look different on different blockchains:
        addr = 0x...; // On some blockchains, it's a long string of numbers and letters.
        addr = wallet1....; // On others, it starts with words and looks a bit friendlier.
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="wrap-up"><a class="header" href="#wrap-up">Wrap-Up</a></h2>
<p>In Move, these primitive types form the foundation of the language, allowing you to count, measure, make decisions, and identify accounts on the blockchain. By understanding integers, booleans, and addresses, you're well on your way to mastering the basics of Move and blockchain programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-in-move"><a class="header" href="#comments-in-move">Comments in Move</a></h1>
<p>After completing this lesson, you'll be able to add in-line and block comments to Move code. And you'll understand best practices for using comments in Move.</p>
<p>Comments in Move programming are like the margin notes in a textbook: they're there to provide clarity, explanations, or to momentarily sideline pieces of code. Comments don't affect the execution of the program. But they can be invaluable for maintaining code readability and understanding, especially when working in teams or revisiting old code.</p>
<h2 id="line-comments-quick-notes-and-side-comments"><a class="header" href="#line-comments-quick-notes-and-side-comments">Line Comments: Quick Notes and Side Comments</a></h2>
<p>Line comments start with // and extend to the end of the line. They're perfect for brief explanations or temporarily disabling code lines. Here's how to use them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun main() {
        // This is a line comment explaining the following variable
        let cups_of_coffee = 2;

        // The next line is commented out and won't execute
        // let cups_of_tea = 3;

        let cups_of_water = 1; // This comment is at the end of a line
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Line comments are straightforward: anything after <code>//</code> on the same line is a comment and ignored during code execution. Use them to add quick notes or disable specific lines of code temporarily.</p>
<h2 id="block-comments-for-longer-explanations-and-large-sections"><a class="header" href="#block-comments-for-longer-explanations-and-large-sections">Block Comments: For Longer Explanations and Large Sections</a></h2>
<p>When you need to annotate more extensively or disable multiple lines of code, block comments are your go-to. These start with /<em>and end with</em>/, spanning across as many lines as needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun calculate_beverages() {
        /* This block comment covers multiple lines, providing a space for
           more detailed explanations or for commenting out larger code sections
           without affecting readability. */
        let total_beverages = 10;

        /* Block comments can also be used inline to comment out
           specific parts of a line or expression. */
        let result = total_beverages /* - 5 */;
    }
    /* Entire functions or sections can be sidelined using block comments,
    making it easy to test different parts of the code.
    fun unused_function() {
        // Code here is not executed
    }
    */
}
<span class="boring">}</span></code></pre></pre>
<p>Block comments offer flexibility for detailed annotations or for excluding chunks of code from execution. They're useful during debugging or when you want to provide comprehensive explanations within your code.</p>
<h2 id="best-practices-for-commenting"><a class="header" href="#best-practices-for-commenting">Best Practices for Commenting</a></h2>
<ul>
<li>
<p><strong>Clarity Over Quantity:</strong> Write comments that clarify complex logic or decisions in your code, but avoid stating the obvious. Good code is self-explanatory for the most part.</p>
</li>
<li>
<p><strong>Maintenance:</strong> Keep comments updated as you modify your code. Outdated comments can be more misleading than no comments at all.</p>
</li>
<li>
<p><strong>Disable With Care:</strong> While commenting out code is handy for quick tests, avoid leaving chunks of unused code in your final version. It clutters the codebase and can confuse others.</p>
</li>
</ul>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Comments are a simple yet powerful feature in Move, enhancing the readability and maintainability of your blockchain applications. Whether you're jotting down a quick note with a line comment or explaining a complex algorithm with a block comment, these annotations are key to building understandable and collaborative codebases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions-and-scope"><a class="header" href="#expressions-and-scope">Expressions and scope</a></h1>
<p>By the end of this lesson, you'll demonstrate mastery of expressions and scope, including being able to evaluate when variables are accessible and what the values of experssions will be after execution.</p>
<p>In Move, expressions and scope are fundamental concepts that dictate how data is manipulated and accessed within your programs. Let's delve deeper into these concepts with more examples to illustrate their practical use in blockchain development.</p>
<h2 id="expressions-the-heart-of-logic-and-calculation"><a class="header" href="#expressions-the-heart-of-logic-and-calculation">Expressions: The Heart of Logic and Calculation</a></h2>
<p>Expressions in Move are any segments of code that compute a value. They're the workhorses of your program, responsible for everything from basic arithmetic to complex function calls. Here are various forms of expressions illustrated with examples:</p>
<ul>
<li><strong>Arithmetic Expressions:</strong> Perform calculations using operators.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun arithmetic_examples() {
        let sum = 5 + 3; // Adds up to 8
        let product = 4 * 7; // Multiplies to 28
        let is_greater = 10 &gt; 5; // Evaluates to true
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Function Calls as Expressions:</strong> When functions return a value, calling them is an expression.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun add(a: u64, b: u64): u64 {
        a + b
    }
    fun function_call_example() {
        let result = add(2, 3); // 'add' function call returns 5
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Conditional Expressions:</strong> Use conditions to determine values.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun max(a: u64, b: u64): u64 {
        if (a &gt; b) { a } else { b }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Expressions enable you to encode the logic of your blockchain application, from simple value assignments to decision-making processes.</p>
<h2 id="scope-organizing-access-and-visibility"><a class="header" href="#scope-organizing-access-and-visibility">Scope: Organizing Access and Visibility</a></h2>
<p>Scope defines where in your code a variable or function is accessible. It's like having different boxes for your tools, where each tool is only available within its designated box.</p>
<ul>
<li><strong>Function Scope:</strong> Variables are accessible only within the function they're declared in.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun function_scope_example() {
        let in_function = "visible inside this function";
        // Access 'in_function' here
    }
    // 'in_function' is not accessible here
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Block Scope:</strong> A more granular level of scope within {}, affecting visibility of variables.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun block_scope_example() {
        {
            let in_block = "visible inside this block";
            // Access 'in_block' here
        }
        // 'in_block' is not accessible here
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Understanding scope is crucial for managing data effectively and ensuring that your program's structure is both secure and logical.</p>
<h2 id="combining-expressions-with-scope"><a class="header" href="#combining-expressions-with-scope">Combining Expressions with Scope</a></h2>
<p>By combining expressions with a clear understanding of scope, you can write concise and powerful Move code. Here’s how they work together in a more complex example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun guess_the_number(guess: u8) {
        let secret_number = 7u8; // Only accessible within this function
        if (guess == secret_number) { // Conditional expression
            // Code to execute if the guess is correct
        } else {
            // Code for an incorrect guess
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the variable secret_number is scoped to the guess_the_number function, and a conditional expression is used to compare guess to secret_number. This structure ensures that secret_number remains hidden outside the function, encapsulating the game's logic securely within its scope.</p>
<h2 id="block-return-values"><a class="header" href="#block-return-values">Block Return Values</a></h2>
<p>A block, delineated by curly braces {}, can contain a series of expressions and has the ability to return a value. This feature is particularly useful for executing a sequence of operations and then utilizing the result of the last expression as the block's output.</p>
<p>Consider you're programming a feature in a blockchain-based game where players can earn rewards based on their achievements. Let's say the reward calculation is slightly complex, involving multiple steps, but you want to keep your code clean and modular. Here's how you might use a block's return value to achieve this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun calculate_reward(points: u64): u64 {
        // A block to calculate the bonus multiplier based on points
        let bonus_multiplier = {
            if (points &gt; 100) { 2 } // More than 100 points doubles the reward
            else if (points &gt; 50) { 1 } // More than 50 points gives a standard reward
            else { 0 } // 50 points or less yields no bonus
            // The last expression's value is returned from the block
        };

        points * bonus_multiplier // The calculated bonus_multiplier is used here
    }

    fun main() {
        let player_points = 75;
        let reward = calculate_reward(player_points);
        // Use `reward` for further operations, like crediting to the player's account
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the calculate_reward function includes a block to determine the bonus_multiplier based on the player's points. The block evaluates the conditions and directly returns the multiplier value, which is then used to calculate the total reward. The absence of a semicolon after the conditionals within the block signifies that the result of the last evaluated expression is the return value of the entire block.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>Expressions and scope in Move are not just theoretical concepts but practical tools that shape how you interact with the blockchain. They allow you to perform calculations, make decisions, and structure your code in a way that aligns with the decentralized and secure nature of blockchain applications. By mastering these elements, you'll be well-equipped to tackle the challenges of blockchain development with Move.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h1>
<p>This lesson will help you gain the ability to use control loops safely. You'll be able to write for loops, while loops, and if statements, debug infinite loops, and assert preconditions in Move.</p>
<p>Move is an imperative language. Control flow mechanisms like loops and conditional statements allow developers to dictate the execution path of their code. This lesson provides an overview of these control structures with practical examples to help you understand how to implement and debug them effectively.</p>
<h2 id="the-if-expression-making-decisions"><a class="header" href="#the-if-expression-making-decisions">The <code>if</code> Expression: Making Decisions</a></h2>
<p>The if expression in Move lets you execute a block of code based on whether a condition is true or false. It's like deciding whether to take an umbrella based on whether it's raining.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun decide_to_wear_sweater(temperature: u8) {
        // If the temperature is less than 20 degrees, wear a sweater.
        if (temperature &lt; 20) {
            // Code to wear a sweater
        } else {
            // Otherwise, no sweater needed
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the decision to wear a sweater is made based on the temperature. The syntax is: <code>if (condition) { ... } else { ... }</code>;</p>
<h2 id="iterating-with-loops"><a class="header" href="#iterating-with-loops">Iterating with Loops</a></h2>
<p>Move supports two types of loops: while for conditional looping and loop for potentially infinite loops.</p>
<h2 id="while-loop-conditional-iteration"><a class="header" href="#while-loop-conditional-iteration"><code>while</code> Loop: Conditional Iteration</a></h2>
<p>Use a while loop when you want to repeat an action until a certain condition becomes false. For example, incrementing a counter until it reaches a specified limit.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun countdown(start: u8) {
        let mut counter = start;
        while (counter &gt; 0) {
            // Code to display the countdown
            counter = counter - 1;
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This loop decrements a counter from a starting value until it hits zero, mimicking a countdown timer.</p>
<h2 id="infinite-loop"><a class="header" href="#infinite-loop">Infinite loop</a></h2>
<p>An infinite loop will run forever unless explicitly exited with break. It's crucial to use it cautiously to avoid infinite loops that can consume excessive resources (gas) on the blockchain.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun infinite_loop_example() {
        let mut i = 0;
        loop {
            i = i + 1;
            if (i == 5) { break; } // Exit the loop when `i` reaches 5
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the loop increments i but exits before it becomes an infinite loop thanks to the break statement.</p>
<h2 id="debugging-infinite-loops"><a class="header" href="#debugging-infinite-loops">Debugging Infinite Loops</a></h2>
<p>Understanding how to safely exit a loop is essential for debugging. Use break to exit loops and continue to skip to the next iteration of the loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun loop_with_conditions() {
        let mut i = 0;
        loop {
            i = i + 1;
            if (i % 2 == 0) { continue; } // Skip even numbers
            if (i &gt; 10) { break; } // Stop looping when `i` exceeds 10
        };
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This loop increments i, skips even numbers using continue, and stops when i is greater than 10 using break.</p>
<h2 id="using-assert-for-preconditions"><a class="header" href="#using-assert-for-preconditions">Using <code>assert!</code> for Preconditions</a></h2>
<p>Move's assert! function is a powerful tool for checking conditions and aborting execution if the condition is not met, preventing unwanted states in your blockchain applications.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    fun transfer_tokens(amount: u64) {
        // Ensure the amount is not zero before proceeding with the transfer
        assert!(amount &gt; 0, 400); // 400 is an arbitrary error code
        // Code to transfer tokens
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, assert! ensures that the token amount to be transferred is not zero, aborting the transaction with an error code if the condition fails.</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Control flow structures in Move, such as if expressions, while and loop loops, and the assert! function, are essential for creating dynamic and safe smart contracts. By leveraging these constructs, developers can write more robust and efficient applications on the blockchain. Practicing with these examples will help you become proficient in controlling the flow of your Move programs and debugging them effectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-and-imports"><a class="header" href="#modules-and-imports">Modules and Imports</a></h1>
<p>In this lesson, you'll gain experience writing Move modules and importing functions and types from other modules.</p>
<p>In Move, a language designed for blockchain development, modules play a crucial role in organizing code, while imports allow for modularization and reusability. Here's an in-depth look at how to create modules and import functions and types from them, illustrated with practical examples.</p>
<h2 id="creating-modules-in-move"><a class="header" href="#creating-modules-in-move">Creating Modules in Move</a></h2>
<p>A module in Move is akin to a package of code that contains functions, types, and resources, encapsulating related functionality under a single namespace. Modules are published under a developer's address and can be utilized by scripts and other modules.</p>
<h2 id="example-defining-a-simple-math-module"><a class="header" href="#example-defining-a-simple-math-module">Example: Defining a Simple Math Module</a></h2>
<p>Let's start with a basic example of a module that performs arithmetic operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module 0x1::SimpleMath {
    // A public function to add two numbers
    public fun add(a: u64, b: u64): u64 {
        a + b
    }

    // A public function to subtract two numbers
    public fun subtract(a: u64, b: u64): u64 {
        a - b
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This SimpleMath module provides two functions, add and subtract, which can be used by other parts of your Move application.</p>
<h2 id="importing-from-modules"><a class="header" href="#importing-from-modules">Importing from Modules</a></h2>
<p>To use the functionality defined in a module, you must import it. This can be done in scripts or other modules.</p>
<p>You can directly reference a module by its address when calling its functions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    use 0x1::SimpleMath;

    fun demonstrate_arithmetic() {
        let sum = SimpleMath::add(5, 3);
        let difference = SimpleMath::subtract(10, 4);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this script, we're using the add and subtract functions from the SimpleMath module to perform arithmetic operations.</p>
<h2 id="using-use-to-import-modules"><a class="header" href="#using-use-to-import-modules">Using <code>use</code> to Import Modules</a></h2>
<p>The use keyword simplifies imports, especially when dealing with multiple functions or types from the same module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use 0x1::SimpleMath;

script {
    fun utilize_math_operations() {
        let total = SimpleMath::add(20, 15);
        let remainder = SimpleMath::subtract(30, 5);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>By importing SimpleMath at the script's beginning, we make its functions readily available for use.</p>
<h2 id="advanced-importing-techniques"><a class="header" href="#advanced-importing-techniques">Advanced Importing Techniques</a></h2>
<p>Move's importing capabilities also include importing specific members of a module or using aliases to avoid naming conflicts.</p>
<p>If you only need certain functions from a module, you can import them individually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use 0x1::SimpleMath::{add, subtract};

script {
    fun math_demo() {
        let sum = add(8, 2); // Directly using the imported `add` function
        let difference = subtract(10, 3); // Using the `subtract` function
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach keeps your script clean and focused, importing only what you need.</p>
<h2 id="example-a-module-for-user-management"><a class="header" href="#example-a-module-for-user-management">Example: A Module for User Management</a></h2>
<p>Consider a module designed for managing user profiles in a decentralized application:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module user_manager_addr::UserManager {
    struct Profile has key {
        username: vector&lt;u8&gt;,
        age: u8,
    }

    public fun create_profile(username: vector&lt;u8&gt;, age: u8): Profile {
        Profile { username, age }
    }

    public fun update_age(profile: &amp;mut Profile, new_age: u8) {
        profile.age = new_age;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here we're using a named address.</p>
<p>For Aptos, in your <code>Move.toml</code> file, under <code>[addresses]</code> you would add:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>user_manager_addr = "&lt;your-account-address&gt;"`
<span class="boring">}</span></code></pre></pre>
<p>to store the UserManager module in your account.</p>
<p>For Sui, in <code>Move.toml</code> under <code>[addresses]</code> you could add user_manager_addr="0x0" to indicate that user_manager_addr is the root of the file. When you publish to Sui, the package will be assigned an arbitrary package ID.</p>
<p>This UserManager module defines a Profile struct and provides functions to create and update a user's profile.</p>
<h2 id="importing-module-contents-into-other-modules"><a class="header" href="#importing-module-contents-into-other-modules">Importing Module Contents into Other Modules</a></h2>
<p>Modules can use functionalities defined in other modules through imports. This promotes code reuse and modularity.</p>
<p>When a module's functionality is needed in another module, you directly reference it using its address and name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module profile_analytics_addr::ProfileAnalytics {
    use &lt;value-of-user-manager-addr&gt;::UserManager;

    public fun display_username_length(profile: &amp;UserManager::Profile): u64 {
        UserManager::Profile::username(profile).length() as u64
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the ProfileAnalytics module, we're using the UserManager::Profile type and directly accessing the username field to compute its length, showcasing how to access types and fields across modules.</p>
<h2 id="using-use-for-easier-access"><a class="header" href="#using-use-for-easier-access">Using <code>use</code> for Easier Access</a></h2>
<p>The use statement simplifies access to external modules by allowing you to refer to them without specifying the full path each time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>address 0x3 {
module EnhancedUserManager {
    use &lt;value-of-user-manager-addr&gt;::UserManager::{Profile, create_profile, update_age};

    public fun birthday(profile: &amp;mut Profile) {
        let current_age = Profile::age(profile);
        UserManager::update_age(profile, current_age + 1);
    }
}
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>EnhancedUserManager</code> imports specific functions and types from <code>UserManager</code>, making it easier to interact with user profiles, such as incrementing a user's age to celebrate a birthday.</p>
<h2 id="advanced-import-techniques"><a class="header" href="#advanced-import-techniques">Advanced Import Techniques</a></h2>
<p>Move's flexible import system also supports member imports and aliasing, providing fine-grained control over module content usage.</p>
<p>You can import only the necessary components from a module, reducing namespace clutter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module TransactionLogger {
    use &lt;value-of-user-manager-addr&gt;::::UserManager::Profile;

    public fun log_profile_creation(profile: &amp;Profile) {
        // Logic to log profile creation
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach imports only the Profile struct, keeping the module focused on its specific logging responsibilities.</p>
<h2 id="aliasing-with-as"><a class="header" href="#aliasing-with-as">Aliasing with <code>as</code></a></h2>
<p>Aliasing resolves naming conflicts and shortens verbose module names for convenience:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module SecureUserManager {
    use &lt;value-of-user-manager-addr&gt;::UserManager as UM;

    public fun secure_age_update(profile: &amp;mut UM::Profile, encrypted_age: u8) {
        // Decrypt age and update profile
        let decrypted_age = decrypt(encrypted_age);
        UM::update_age(profile, decrypted_age);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>SecureUserManager uses UM as an alias for UserManager, streamlining access to the original module's functionality while adding an encryption layer.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>By leveraging modules and imports, Move developers can build well-organized, modular, and reusable code. This structured approach facilitates collaboration across large-scale projects by clearly defining, isolating and reusing different components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-in-move"><a class="header" href="#testing-in-move">Testing in Move</a></h1>
<p>In this lesson, you'll learn how to unit test Move code to make sure your program works as expected.</p>
<h2 id="chapter-quiz-check-your-knowledge-and-earn-rewards-1"><a class="header" href="#chapter-quiz-check-your-knowledge-and-earn-rewards-1">Chapter Quiz: Check your knowledge and earn rewards</a></h2>
<iframe data-tally-src="https://tally.so/embed/w7WgrL?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="352" frameborder="0" marginheight="0" marginwidth="0" title="Movement Hack Chapter 4 Quiz"></iframe><script>var d=document,w="https://tally.so/widgets/embed.js",v=function(){"undefined"!=typeof Tally?Tally.loadEmbeds():d.querySelectorAll("iframe[data-tally-src]:not([src])").forEach((function(e){e.src=e.dataset.tallySrc}))};if("undefined"!=typeof Tally)v();else if(d.querySelector('script[src="'+w+'"]')==null){var s=d.createElement("script");s.src=w,s.onload=v,s.onerror=v,d.body.appendChild(s);}</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types-and-generics"><a class="header" href="#custom-types-and-generics">Custom types and generics</a></h1>
<p>Remember in the first chapter, where you learned about linear types as a safety feature of Move?</p>
<p>In this chapter you'll dig into how those types work to give Move developers Superpowers.</p>
<p>Through real-world examples, you'll develop a solid foundation in programming with custom types and generics:</p>
<ul>
<li><a href="ch05-01-custom-types.html">Custom Types</a></li>
<li><a href="ch05-02-getter-functions.html">Getter and Setter Functions</a></li>
<li><a href="ch05-03-generics-intro.html">Generics Introduction</a></li>
<li><a href="ch05-04-generics-abilities.html">Generics to Constrain Abilities</a></li>
<li><a href="ch05-05-generics-with-multiple-types.html">Generics with Multiple Type Parameters</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types-structs"><a class="header" href="#custom-types-structs">Custom types (structs)</a></h1>
<p>In this lesson, you'll create structs to define custom types. And you'll apply abilities to structs to make them work in real-world applications.</p>
<p>Structs in Move are foundational for defining custom types, allowing developers to encapsulate and manage complex data within blockchain applications. This lesson delves into creating structs with various real-world examples, illustrating their versatility and power in data modeling.</p>
<h2 id="struct-definition"><a class="header" href="#struct-definition">Struct Definition</a></h2>
<p>A struct is defined using the struct keyword, followed by its name and a list of fields enclosed in curly braces. Each field must have a specified type.</p>
<p><strong>Example: A User Profile</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module UserProfile {
    struct Profile {
        username: vector&lt;u8&gt;,
        email: vector&lt;u8&gt;,
        age: u64,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This <code>Profile</code> struct represents a user profile in an application, with fields for the username, email, and age.</p>
<h2 id="nested-structs"><a class="header" href="#nested-structs">Nested Structs</a></h2>
<p>Structs can contain other structs, enabling the modeling of complex hierarchical data.</p>
<p><strong>Example: Product Catalog</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module ProductCatalog {
    struct Price {
        amount: u64,
        currency: vector&lt;u8&gt;,
    }
​
    struct Product {
        id: u64,
        name: vector&lt;u8&gt;,
        price: Price,
    }
​
    struct Catalog {
        products: vector&lt;Product&gt;,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, ProductCatalog defines a system for managing products, each with a <code>Price</code>. The Catalog struct holds a collection of Product instances.</p>
<h2 id="struct-abilities"><a class="header" href="#struct-abilities">Struct Abilities</a></h2>
<p>Structs in Move can be annotated with abilities that define how they can be used, such as copy, drop, store, or key.</p>
<p><strong>Example: A Tradable Asset</strong></p>
<p>module AssetManager {
struct Asset has store {
id: u64,
owner: address,
value: u64,
}
}
The Asset struct is marked with the store ability, indicating it can be stored persistently in global storage, suitable for representing tradable assets.
Creating and Initializing Structs
Struct instances are typically created and initialized within functions. Move allows for direct field initialization or using variable names that match struct fields.</p>
<p><strong>Example: Creating a New Asset</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module AssetManager {
    // Assuming Asset struct is defined above...
​
    public fun create_asset(owner: address, asset_id: u64, asset_value: u64): Asset {
        Asset { owner: owner, id: asset_id, value: asset_value }
        // Or simply: Asset { owner, id: asset_id, value: asset_value }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function demonstrates creating a new Asset, highlighting the flexibility in struct initialization.</p>
<h2 id="accessing-struct-fields"><a class="header" href="#accessing-struct-fields">Accessing Struct Fields</a></h2>
<p>Access to struct fields is determined by their visibility. Within the module, fields can be accessed directly. Outside, accessor methods are needed.</p>
<p><strong>Example: Accessing and Modifying Asset Value</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module AssetManager {
    // Assuming Asset struct and create_asset function are defined...

    public fun get_asset_value(asset: &amp;Asset): u64 {
        asset.value
    }

    public fun update_asset_value(asset: &amp;mut Asset, new_value: u64) {
        asset.value = new_value;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>These functions provide read and write access to an Asset's value, showcasing field access control.</p>
<h2 id="structs-with-vectors"><a class="header" href="#structs-with-vectors">Structs with Vectors</a></h2>
<p>Vectors within structs enable dynamic collections of elements, useful for managing lists of items or records.</p>
<p><strong>Example: A Voting System</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module VotingSystem {
    struct Vote {
        candidate_id: u64,
        voter_id: address,
    }

    struct Ballot {
        votes: vector&lt;Vote&gt;,
    }

    public fun cast_vote(ballot: &amp;mut Ballot, vote: Vote) {
        Vector::push_back(&amp;mut ballot.votes, vote);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In <code>VotingSystem</code>, <code>Ballot</code> holds a collection of <code>Vote</code> structs, with functionality to cast new votes.</p>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>Structs in Move are a powerful tool for defining custom types, enabling the modeling of complex data structures essential for blockchain applications. From simple user profiles to intricate product catalogs, structs offer the flexibility to create nuanced and sophisticated data models.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getter-and-setter-functions"><a class="header" href="#getter-and-setter-functions">Getter and setter functions</a></h1>
<p>In this lesson, you'll implement "getter" and "setter" functions to access and change the values of fields in custom types.</p>
<h2 id="getter-functions"><a class="header" href="#getter-functions">Getter Functions</a></h2>
<p>Getter functions are public functions that allow reading the values of private fields in a struct. They are essential for accessing data encapsulated within a struct from outside the module.</p>
<p><strong>Example: Accessing Account Information</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module AccountManager {
    struct Account {
        id: address,
        balance: u64,
    }
​
    public fun create_account(id: address, initial_balance: u64): Account {
        Account { id, balance: initial_balance }
    }
​
    // Getter for account ID
    public fun get_id(account: &amp;Account): address {
        account.id
    }
​
    // Getter for account balance
    public fun get_balance(account: &amp;Account): u64 {
        account.balance
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>get_id</code> and <code>get_balance</code> are getter functions allowing external access to an Account struct's id and balance fields, respectively.</p>
<h2 id="setter-functions"><a class="header" href="#setter-functions">Setter Functions</a></h2>
<p>Getter functions allow external code to read struct fields values. Setter functions allowing external code to "write" or modify the values of private fields in a struct. These functions allow you to update data in a controlled manner, ensuring any modifications are valid and safe.</p>
<p><strong>Example: Updating Account Balance</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module AccountManager {
    // Assuming Account struct is defined as before...
​
    // Setter for updating account balance
    public fun set_balance(account: &amp;mut Account, new_balance: u64) {
        // Additional logic can be included here to validate the new balance
        account.balance = new_balance;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>set_balance</code> function allows the balance of an Account to be updated from outside the module. It takes a mutable reference to an Account and a new balance value, updating the balance field directly.</p>
<h2 id="considerations-for-getter-and-setter-functions"><a class="header" href="#considerations-for-getter-and-setter-functions">Considerations for Getter and Setter Functions</a></h2>
<ul>
<li>
<p><strong>Validation:</strong> Setter functions can include validation logic to ensure that attempts to modify a struct's field adhere to specific rules or constraints. This is crucial for maintaining the integrity of the application's state.</p>
</li>
<li>
<p><strong>Performance:</strong> Frequent use of getter and setter functions may have implications on performance, especially in a blockchain context where operations have a cost. It's important to balance the need for external access with efficiency.</p>
</li>
<li>
<p><strong>Security:</strong> Getter and setter functions should be designed with security in mind, especially when dealing with sensitive or critical data. Proper validation and access controls can help prevent unauthorized or harmful modifications.</p>
</li>
</ul>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>Getter and setter functions in Move provide a safe and structured way to access and modify the fields of a struct from outside the module where it's defined. By carefully implementing these functions, developers can ensure data encapsulated within structs is accessible and mutable in a controlled and secure manner.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-introduction"><a class="header" href="#generics-introduction">Generics Introduction</a></h1>
<p>Generics are a cornerstone of Move's design, offering flexibility and reusability in smart contract development. This guide will break down the concept of generics in Move with practical, real-world examples.</p>
<p>Generics allow the creation of functions and structs that can operate on many data types, making code more reusable and adaptable.</p>
<h2 id="move-and-copy-generics"><a class="header" href="#move-and-copy-generics">Move and copy Generics</a></h2>
<p>Suppose you want to transfer different types of assets (e.g., tokens, NFTs) using the same function. Generics make this possible.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module AssetManager {
    struct Asset&lt;T&gt; has key, store {
        id: u64,
        content: T,
    }
​
    public fun transfer&lt;T: key + store&gt;(asset: Asset&lt;T&gt;, new_owner: address) {
        // Implementation for transferring asset to new_owner
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function can now be used to transfer any asset, regardless of its content type, as long as it conforms to the key + store constraints, ensuring the asset can be stored and uniquely identified.</p>
<h2 id="the-copy-keyword-in-generics"><a class="header" href="#the-copy-keyword-in-generics">The <code>copy</code> Keyword in Generics</a></h2>
<p>Suppose you need to clone a container holding any type of item.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module BoxManager {
    struct Box&lt;T&gt; has copy {
        item: T,
    }
​
    public fun clone_box&lt;T: copy&gt;(original: &amp;Box&lt;T&gt;): Box&lt;T&gt; {
        Box { item: *original.item }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>clone_box</code> can duplicate any box with contents that have the <code>copy</code> ability. This is called using generics to constrain abilities.</p>
<h2 id="references-and-borrow-checking"><a class="header" href="#references-and-borrow-checking">References and Borrow Checking</a></h2>
<p>Generics combined with references enable functions to work with any account model while ensuring safety through borrow checking.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module AccountManager {
    struct Account&lt;T&gt; {
        balance: T,
    }
​
    public fun deposit&lt;T&gt;(account: &amp;mut Account&lt;T&gt;, amount: T) where T: copy + std::ops::Add&lt;T, Output = T&gt; {
        account.balance = account.balance + amount;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function allows adding funds to any account type, leveraging Move's generics and references to ensure type safety and flexibility.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-with-multiple-types-in-move"><a class="header" href="#generics-with-multiple-types-in-move">Generics with Multiple Types in Move</a></h1>
<p>Generics aren't limited to single-type scenarios; Move allows defining structs and functions with multiple generic types, expanding the versatility and reusability of code. This feature is particularly useful when designing complex data structures or functions that need to operate on more than one type of data.</p>
<p><strong>Example: Pair Storage</strong></p>
<p>Imagine a module that needs to store pairs of items, which could be of any type. Using generics with multiple types, you can create a struct that accommodates pairs of different types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module PairManager {
    struct Pair&lt;T1, T2&gt; {
        first: T1,
        second: T2,
    }

    public fun create_pair&lt;T1, T2&gt;(first: T1, second: T2): Pair&lt;T1, T2&gt; {
        Pair { first, second }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This <code>Pair</code> struct can hold any combination of types, making it a flexible solution for various scenarios, such as storing key-value pairs where keys and values are of different types.</p>
<h2 id="practical-application-currency-conversion-rates"><a class="header" href="#practical-application-currency-conversion-rates">Practical Application: Currency Conversion Rates</a></h2>
<p>Consider an application that needs to manage currency conversion rates, which involve a pair of currencies and their conversion rate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module CurrencyConverter {
    struct CurrencyCode {}

    struct ConversionRate&lt;T1, T2&gt; {
        from_currency: T1,
        to_currency: T2,
        rate: f64,
    }

    public fun set_rate&lt;T1, T2&gt;(from: T1, to: T2, rate: f64): ConversionRate&lt;T1, T2&gt; {
        ConversionRate { from_currency: from, to_currency: to, rate }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>ConversionRate</code> uses generics to allow for flexibility in the types of currencies it can accept, potentially accommodating various currency representations.</p>
<h2 id="working-with-multiple-generic-types"><a class="header" href="#working-with-multiple-generic-types">Working with Multiple Generic Types</a></h2>
<p>A common utility operation is swapping the values of two variables. With generics, you can create a versatile swap function that works with any type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module Utils {
    public fun swap&lt;T1, T2&gt;(first: &amp;mut T1, second: &amp;mut T2) {
        let temp = *first;
        *first = *second;
        *second = temp;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This swap function can interchange the values of two variables of different types, showcasing the power of generics in creating highly reusable code components.</p>
<h2 id="constraints-on-multiple-generic-types"><a class="header" href="#constraints-on-multiple-generic-types">Constraints on Multiple Generic Types</a></h2>
<p>When working with multiple generic types, you can apply constraints to each type parameter independently, ensuring they meet certain requirements or abilities.</p>
<p><strong>Example: Key-Value Storage with Constraints</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module Storage {
    struct KeyValue&lt;T1: key, T2: store&gt; {
        key: T1,
        value: T2,
    }

    public fun create_key_value&lt;T1: key, T2: store&gt;(key: T1, value: T2): KeyValue&lt;T1, T2&gt; {
        KeyValue { key, value }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this <code>KeyValue</code> struct, constraints ensure that the <code>key</code> has the <code>key</code> ability (making it suitable for use as a unique identifier) and the <code>value</code> has the <code>store</code> ability (ensuring it can be saved in global storage).</p>
<h3 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h3>
<p>From asset management to e-commerce, the practical examples illustrated here demonstrate how generics underpin Move's versatility and safety. Generics with multiple types enhance the capability to write flexible and reusable code in Move. Generics underline Move's strength in supporting the development of complex smart contracts and decentralized applications.</p>
<h3 id="chapter-quiz-get-credit-on-galxe-for-weekly-rewards"><a class="header" href="#chapter-quiz-get-credit-on-galxe-for-weekly-rewards">Chapter Quiz: Get credit on Galxe for weekly rewards</a></h3>
<iframe data-tally-src="https://tally.so/embed/w2ezrV?alignLeft=1&hideTitle=1&transparentBackground=1&dynamicHeight=1" loading="lazy" width="100%" height="415" frameborder="0" marginheight="0" marginwidth="0" title="Movement Hack Chapter 5 Quiz"></iframe><script>var d=document,w="https://tally.so/widgets/embed.js",v=function(){"undefined"!=typeof Tally?Tally.loadEmbeds():d.querySelectorAll("iframe[data-tally-src]:not([src])").forEach((function(e){e.src=e.dataset.tallySrc}))};if("undefined"!=typeof Tally)v();else if(d.querySelector('script[src="'+w+'"]')==null){var s=d.createElement("script");s.src=w,s.onload=v,s.onerror=v,d.body.appendChild(s);}</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
